@implements IAsyncDisposable
@page "/"
@rendermode InteractiveServer
@inject HomeViewModel ViewModel
@inject IJSRuntime JS

<RadzenLayout Style="user-select: none">
    <RadzenHeader>
        <RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center">
            <RadzenSidebarToggle Click="() => toggleExpanded = !toggleExpanded" />
            <RadzenText>Tree No.</RadzenText>
            <RadzenNumeric TValue="int" Min="1" Max="Math.Max(ViewModel.MaxTreeIndex.Value, 1)" @bind-Value="ViewModel.TreeIndex.Value" Disabled="@(ViewModel.MaxTreeIndex.Value == 0)" Style="width: 50px" />
            <RadzenRadioButtonList TValue="TreeEditMode" @bind-Value="ViewModel.EditMode.Value">
                <Items>
                    <RadzenRadioButtonListItem Text="Select" Value="TreeEditMode.Select" />
                    <RadzenRadioButtonListItem Text="Reroot" Value="TreeEditMode.Reroot" />
                    <RadzenRadioButtonListItem Text="Swap" Value="TreeEditMode.Swap" />
                    <RadzenRadioButtonListItem Text="Subtree" Value="TreeEditMode.Subtree" />
                </Items>
            </RadzenRadioButtonList>
            @if (ViewModel.EditMode.Value == TreeEditMode.Select)
            {
                <RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="0">
                    <RadzenStack>
                        <RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center">
                            <RadzenRadioButtonList TValue="SelectionMode" @bind-Value="ViewModel.SelectionTarget.Value">
                                <Items>
                                    <RadzenRadioButtonListItem Text="Node" Value="SelectionMode.Node" />
                                    <RadzenRadioButtonListItem Text="Clade" Value="SelectionMode.Clade" />
                                    <RadzenRadioButtonListItem Text="Taxa" Value="SelectionMode.Taxa" />
                                </Items>
                            </RadzenRadioButtonList>
                        </RadzenStack>
                    </RadzenStack>
                    <RadzenText>Selection Mode</RadzenText>
                </RadzenStack>
            }
        </RadzenStack>
    </RadzenHeader>
    <RadzenSidebar Responsive="false" @bind-Expanded="toggleExpanded" Style="width: 300px">
        <TreeEditSidebar />
    </RadzenSidebar>
    <RadzenBody>
        <RadzenSplitter Orientation="Orientation.Horizontal">
            <RadzenSplitterPane Size="calc(100% - 300px)" Style="overflow: scroll">
                @if (ViewModel.TargetTree.Value is not null)
                {
                    Configurations config = Configurations.LoadOrCreate();

                    Tree tree = ViewModel.TargetTree.Value;
                    positionManager.Reset(tree);

                    (double svgWidth, double svgHeight) = positionManager.CalcDocumentSize();

                    <svg width="@svgWidth" height="@svgHeight">
                        <style type="text/css">
                            text {
                                font-family: Arial, Helvetica, sans-serif;
                            }

                            .leaf {
                                font-size: @(tree.Style.LeafLabelsFontSize + "px");
                            }

                            .clade-label {
                                font-size: @(tree.Style.CladeLabelsFontSize + "px");
                            }

                            .node-value {
                                font-size: @(tree.Style.NodeValueFontSize + "px");
                            }

                            .branch-value {
                                font-size: @(tree.Style.BranchValueFontSize + "px");
                            }

                            .branch {
                                fill: none;
                                stroke-width: @(tree.Style.BranchThickness + "px");
                            }

                            .collapsed-rectangle {
                                fill: none;
                                stroke-width: @(tree.Style.BranchThickness + "px");
                            }

                            .scalebar-line {
                                fill: none;
                                stroke: black;
                                stroke-width: @(tree.Style.ScaleBarThickness + "px");
                            }

                            .scalebar-text {
                                font-size: @(tree.Style.ScaleBarFontSize + "px");
                            }

                            .clickable-leaf {
                                stroke: none;
                            }

                            .clickable-branch {
                                fill: none;
                            }
                        </style>
                        <rect width="100%" height="100%" style="fill: transparent; stroke: none" onclick="@ViewModel.UnfocusAllCommand.ToDelegate()" />
                        <g transform="translate(50, 50)">
                            @foreach (Clade current in tree.GetAllClades())
                            {
                                if (current.GetIsHidden()) continue;

                                // 折り畳み
                                if (current.GetIsExternal() && !current.IsLeaf)
                                {
                                    var (left, rightTop, rightBottom) = positionManager.CalcCollapseTrianglePositions(current);

                                    <path class="collapsed-rectangle" d="M @left.x @left.y
                                                                         L @rightTop.x @rightTop.y
                                                                         L @rightBottom.x @rightBottom.y
                                                                         L @left.x @left.y" stroke="@current.Style.BranchColor" />
                                }

                                if (current.IsLeaf)
                                {
                                    // 系統名
                                    if (tree.Style.ShowLeafLabels && !string.IsNullOrEmpty(current.Taxon))
                                    {
                                        (double x, double y, double width, double height) = positionManager.CalcLeafPosition(current);

                                        var svgText = new MarkupString($"<text class=\"leaf\" x=\"{x}\" y=\"{y}\" style=\"fill: {current.Style.LeafColor}\">{current.Taxon}</text>");
                                        @svgText

                                        // クリックエリア
                                        if (ViewModel.EditMode.Value == TreeEditMode.Select)
                                        {
                                            CladeId id = current.GetId(CladeIdSuffix.Leaf);
                                            string fillColor = ViewModel.FocusedSvgElementIdList.Contains(id) ? "#A0D8EFC4" : "transparent";
                                            const int margin = 3;

                                            <rect id="@id" class="clickable-leaf" x="@(x - margin)" y="@(y - height - margin)" width="@(width + margin * 2)" height="@(height + margin * 2)"
                                                  style="fill: @fillColor" onclick="@ViewModel.SvgElementClickedCommand.ToDelegate(id)" />
                                        }
                                    }
                                }
                                else
                                {
                                    // 結節点の値
                                    @if (tree.Style.ShowNodeValues && !current.GetIsExternal())
                                    {
                                        string nodeValue = SelectShowValue(current, tree.Style.NodeValueType);
                                        if (nodeValue.Length > 0)
                                        {
                                            (double x, double y) = positionManager.CalcNodeValuePosition(current, nodeValue);

                                            var svgText = new MarkupString($"<text class=\"node-value\" x=\"{x}\" y=\"{y}\" style=\"fill: {current.Style.BranchColor}\">{nodeValue}</text>");
                                            @svgText
                                        }
                                    }
                                }

                                // クレード名
                                if (tree.Style.ShowCladeLabels && !string.IsNullOrEmpty(current.Style.CladeLabel))
                                {
                                    var (line, text) = positionManager.CalcCladeLabelPosition(current);

                                    @if (tree.Style.CladeLabelsLineThickness > 0)
                                    {
                                        <line x1="@line.x" x2="@line.x" y1="@line.yTop" y2="@line.yBottom" stroke="black" stroke-width="@tree.Style.CladeLabelsLineThickness" />
                                    }
                                    var svgText = new MarkupString($"<text class=\"clade-label\" x=\"{text.x}\" y=\"{text.y}\">{current.Style.CladeLabel}</text>");
                                    @svgText
                                }

                                if (current.BranchLength > 0)
                                {
                                    // 横棒
                                    {
                                        (double xParent, double xChild, double y) = positionManager.CalcHorizontalBranchPositions(current);

                                        string stroke;
                                        if (config.BranchColoring is BranchColoringType.Both or BranchColoringType.Horizontal) stroke = current.Style.BranchColor;
                                        else stroke = "black";
                                        <line class="branch" x1="@xParent" y1="@y" x2="@xChild" y2="@y" style="stroke: @(stroke)" />
                                    }

                                    // 枝の装飾
                                    if (ViewModel.EditMode.Value is TreeEditMode.Select or TreeEditMode.Swap && tree.Style.ShowBranchDecorations && !string.IsNullOrEmpty(current.Supports))
                                        foreach (BranchDecorationStyle currentDecoration in tree.Style.DecorationStyles.Where(x => x.Enabled && (x.Regex?.IsMatch(current.Supports) ?? false)))
                                        {
                                            string color = currentDecoration.ShapeColor;

                                            switch (currentDecoration.DecorationType)
                                            {
                                                case BranchDecorationType.ClosedCircle:
                                                case BranchDecorationType.OpenCircle:
                                                    {
                                                        (double centerX, double centerY, double radius) = positionManager.CalcBranchDecorationCircleArea(current, currentDecoration);

                                                        string fill, stroke;
                                                        if (currentDecoration.DecorationType == BranchDecorationType.ClosedCircle)
                                                        {
                                                            fill = color;
                                                            stroke = "none";
                                                        }
                                                        else
                                                        {
                                                            fill = "white";
                                                            stroke = color;
                                                        }

                                                        <circle cx="@centerX" cy="@centerY" r="@radius" style="stroke: @stroke; fill: @fill" />
                                                    }
                                                    break;
                                                case BranchDecorationType.ClosedRectangle:
                                                case BranchDecorationType.OpenedRectangle:
                                                    {
                                                        (double x, double y, double width, double height) = positionManager.CalcBranchDecorationRectangleArea(current, currentDecoration);

                                                        string fill, stroke;
                                                        if (currentDecoration.DecorationType == BranchDecorationType.ClosedRectangle)
                                                        {
                                                            fill = color;
                                                            stroke = "none";
                                                        }
                                                        else
                                                        {
                                                            fill = "white";
                                                            stroke = color;
                                                        }

                                                        <rect x="@x" y="@y" width="@width" height="@height" style="stroke: @stroke; fill: @fill" />
                                                    }
                                                    break;
                                            }
                                        }
                                    if (ViewModel.EditMode.Value is TreeEditMode.Reroot && !current.IsRoot && !current.IsLeaf && (tree.IsUnrooted || !current.Parent.IsRoot))
                                    {
                                        const double size = 5;
                                        double x = (positionManager.CalcX1(current) + positionManager.CalcX2(current)) / 2 - size;
                                        double y = positionManager.CalcY1(current) - size;

                                        <rect x="@x" y="@y" width="@(size * 2)" height="@(size * 2)" style="stroke: black; stroke-width: 2px; fill: white" onclick="@ViewModel.RerootCommand.ToDelegate((current, true))" />

                                    }
                                    if (ViewModel.EditMode.Value is TreeEditMode.Subtree && !current.IsRoot && !current.IsLeaf)
                                    {
                                        const double size = 5;
                                        double x = (positionManager.CalcX1(current) + positionManager.CalcX2(current)) / 2 - size;
                                        double y = positionManager.CalcY1(current) - size;

                                        <rect x="@x" y="@y" width="@(size * 2)" height="@(size * 2)" style="stroke: transparent; stroke-width: 2px; fill: black" onclick="@ViewModel.ExtractSubtreeCommand.ToDelegate(current)" />

                                    }

                                    // 二分岐の値
                                    if (tree.Style.ShowBranchValues)
                                    {
                                        string branchValue = SelectShowValue(current, tree.Style.BranchValueType);
                                        if (branchValue.Length > 0 && (!tree.Style.BranchValueHideRegex?.IsMatch(branchValue) ?? true))
                                        {
                                            (double x, double y) = positionManager.CalcBranchValuePosition(current, branchValue);

                                            var svgText = new MarkupString($"<text class=\"branch-value\" x=\"{x}\" y=\"{y}\" text-anchor=\"middle\" style=\"fill: {current.Style.BranchColor}\">{branchValue}</text>");
                                            @svgText
                                        }
                                    }
                                }

                                Clade? parent = current.Parent;
                                if (parent is not null)
                                {
                                    if (parent.Children.Count > 1)
                                    {
                                        (double x, double yParent, double yChild) = positionManager.CalcVerticalBranchPositions(current);

                                        // 縦棒
                                        if (yParent != yChild)
                                        {
                                            string stroke;
                                            if (config.BranchColoring is BranchColoringType.Both or BranchColoringType.Vertical) stroke = current.Style.BranchColor;
                                            else stroke = "black";
                                            <line class="branch" x1="@x" y1="@yParent" x2="@x" y2="@yChild" style="stroke: @stroke" />
                                        }
                                    }
                                }

                                // 枝クリックエリア
                                if (ViewModel.EditMode.Value == TreeEditMode.Select)
                                {
                                    double x2 = positionManager.CalcX2(current);

                                    if (!double.IsNaN(x2))
                                    {
                                        double x1 = positionManager.CalcX1(current);
                                        double y1 = positionManager.CalcY1(current);
                                        double y2 = positionManager.CalcY2(current);

                                        string path = $"M {x2} {y1}";
                                        if (x1 != x2) path += $"H {x1}";
                                        if (y1 != y2) path += $"V {y2}";

                                        CladeId id = current.GetId(CladeIdSuffix.Branch);
                                        string strokeColor = ViewModel.FocusedSvgElementIdList.Contains(id) ? "#A0D8EFC4" : "transparent";

                                        <path id="@id" class="clickable-branch" d="@path"
                                              style="stroke: @strokeColor; stroke-width: @(tree.Style.BranchThickness + 4)"
                                              onclick="@ViewModel.SvgElementClickedCommand.ToDelegate(id)" />
                                    }
                                }

                                // 結節点クリックエリア
                                if (ViewModel.EditMode.Value == TreeEditMode.Reroot && !current.IsLeaf && !current.IsRoot)
                                {
                                    CladeId id = current.GetId(CladeIdSuffix.Node);
                                    (double x, double y, double width, double height) = positionManager.CalcNodeDecorationRectangleArea(current);

                                    <rect id="@id" x="@x" y="@y" width="@width" height="@height" style="fill: black; stroke: transparent; stroke-width: 2px" onclick="@ViewModel.RerootCommand.ToDelegate((current, false))" />
                                }
                                else if (ViewModel.EditMode.Value == TreeEditMode.Swap && !current.IsRoot)
                                {
                                    CladeId id = current.GetId(CladeIdSuffix.Node);
                                    int index = current.Parent.Children.IndexOf(current);

                                    if (index < current.Parent.Children.Count - 1)
                                    {
                                        Clade sister = current.Parent.Children[index + 1];

                                        double x = positionManager.CalcX1(current) - 5;
                                        double y = (positionManager.CalcY1(current) + positionManager.CalcY1(sister)) / 2 - 5;

                                        <rect id="@id" x="@x" y="@y" width="10" height="10" style="fill: black; stroke: transparent; stroke-width: 2px" onclick="@ViewModel.SwapSisterCommand.ToDelegate((current, sister))" />
                                    }
                                }
                            }
                        </g>

                        // Scale bar
                        @if (tree.Style.ShowScaleBar && tree.Style.ScaleBarValue > 0)
                        {
                            (double offsetX, double offsetY) = positionManager.CalcScaleBarOffset();
                            ((double xLeft, double xRight, double y) line, (double x, double y) text) = positionManager.CalcScaleBarPositions();

                            <g transform="translate(@offsetX, @offsetY)">
                                <text class="scalebar-text" x="@(text.x)" y="@(text.y)" text-anchor="middle">@tree.Style.ScaleBarValue</text>
                                <line class="scalebar-line" x1="@(line.xLeft)" y1="@(line.y)" x2="@(line.xRight)" y2="@(line.y)" />
                            </g>
                        }
                    </svg>
                }
            </RadzenSplitterPane>
            <RadzenSplitterPane Size="300px">
                <div style="margin: 5px">
                    <StyleSidebar />
                </div>
            </RadzenSplitterPane>
        </RadzenSplitter>
    </RadzenBody>
</RadzenLayout>

@code {
    private bool toggleExpanded = true;
    private IJSObjectReference? jsModule;

    private readonly PositionManager positionManager = new();

    private string SelectShowValue(Clade clade, CladeValueType valueType)
    {
        switch (valueType)
        {
            case CladeValueType.Supports:
                string supports = clade.Supports ?? string.Empty;
                return supports.Trim();
            case CladeValueType.BranchLength:
                double branchLength = clade.BranchLength;
                if (double.IsNaN(branchLength)) return string.Empty;
                return branchLength.ToString();

            default: return string.Empty;
        }
    }

    /// <inheritdoc/>
    protected async override Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        ViewModel.PropertyChanged += (x, y) => InvokeAsync(StateHasChanged);
    }

    /// <inheritdoc/>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Pages/Home.razor.js");
            await jsModule.InvokeVoidAsync("bypassShortcuts", DotNetObjectReference.Create(this));
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (jsModule is not null)
            try
            {
                await jsModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
    }

    /// <summary>
    /// プロジェクトを新規作成します。。
    /// </summary>
    [JSInvokable]
    public void CreateNew()
    {
        ViewModel.CreateNewCommand.Execute();
    }

    /// <summary>
    /// undoを実行します。
    /// </summary>
    [JSInvokable]
    public void Undo()
    {
        ViewModel.UndoCommand.Execute();
    }

    /// <summary>
    /// redoを実行します。
    /// </summary>
    [JSInvokable]
    public void Redo()
    {
        ViewModel.RedoCommand.Execute();
    }

    /// <summary>
    /// 全てを選択します。
    /// </summary>
    [JSInvokable]
    public void FocusAll()
    {
        ViewModel.FocusAllCommand.Execute();
    }
}
